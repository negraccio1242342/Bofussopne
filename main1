-- Aim Lock Core w/ Resolver & Checks
local config = getgenv().Script and getgenv().Script["Aim assist"]
if not config or not config.Enabled then return end

--// Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

--// Config
local Smoothness = config.smoothing or 0.00125
local Shake = config.shake or 0
local Keybind = config.Keybind or Enum.KeyCode.N
local ResolverMode = config.Resolver or "None"
local Checks = config.Checks or {
    Alive = true,
    Team = true,
    Wall = true,
    Visible = true,
    Knocked = true
}

--// State
local lockTarget = nil
local isLocked = false

--// Utils
local function isAlive(character)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Health > 0
end

local function isVisible(part)
    local origin = Camera.CFrame.Position
    local direction = (part.Position - origin).Unit * 999
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = {LocalPlayer.Character, part.Parent}
    params.FilterType = Enum.RaycastFilterType.Blacklist

    local result = Workspace:Raycast(origin, direction, params)
    return not result or result.Instance:IsDescendantOf(part.Parent)
end

local function isKnocked(player)
    local effects = player.Character and player.Character:FindFirstChild("BodyEffects")
    local ko = effects and effects:FindFirstChild("K.O")
    return ko and ko.Value
end

local function passesChecks(player)
    if player == LocalPlayer or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return false end

    if Checks.Alive and not isAlive(player.Character) then return false end
    if Checks.Team and player.Team == LocalPlayer.Team then return false end
    if Checks.Knocked and isKnocked(player) then return false end

    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    if Checks.Visible and not isVisible(hrp) then return false end
    if Checks.Wall and not isVisible(hrp) then return false end -- basic wall = same as visibility

    return true
end

-- Resolver
local function applyResolverVelocity(player, position)
    if ResolverMode == "None" then return position end

    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return position end

    local velocity = hrp.Velocity
    local factor = 0.13 -- Default, tweak or link to user config

    if ResolverMode == "Osiris" then
        return position + (velocity * factor)
    elseif ResolverMode == "Aggressive" then
        return position + (velocity * (factor * 1.5))
    elseif ResolverMode == "Safe" then
        return position + (velocity * (factor * 0.75))
    end

    return position
end

-- Target Logic
local function getClosestTarget()
    local closest, shortest = nil, math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if passesChecks(player) then
            local hrp = player.Character.HumanoidRootPart
            local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - UserInputService:GetMouseLocation()).Magnitude
                if dist < shortest then
                    shortest = dist
                    closest = player
                end
            end
        end
    end
    return closest
end

-- Keybind
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Keybind then
        isLocked = not isLocked
        if isLocked then
            lockTarget = getClosestTarget()
        else
            lockTarget = nil
        end
    end
end)

-- Main Loop
RunService.RenderStepped:Connect(function()
    if isLocked and lockTarget and passesChecks(lockTarget) then
        local hrp = lockTarget.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local predicted = applyResolverVelocity(lockTarget, hrp.Position)
            local camCF = Camera.CFrame
            local newCF = CFrame.lookAt(camCF.Position, predicted)
            Camera.CFrame = camCF:Lerp(newCF, Smoothness)

            if Shake > 0 then
                local shakeOffset = Vector3.new(
                    math.random(-Shake, Shake) * 0.001,
                    math.random(-Shake, Shake) * 0.001,
                    math.random(-Shake, Shake) * 0.001
                )
                Camera.CFrame = Camera.CFrame * CFrame.new(shakeOffset)
            end
        end
    end
end)
